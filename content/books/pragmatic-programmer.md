---
title: "Pragmatic Programmer"
date: 2022-08-23T21:27:29-05:00
draft: true 
---

##### ~Extract from the book of david Thomas and Andrew Hunt

> Programming is about trying to make the future less painful. It's about making things easier for our teammates. It's about getting things wrong and being able to bounce back. It's about forming good habits. It's about understanding your toolset. Coding is just part of th worl of being a programmer.
> ~ [pragprom]


>There is a unique dedication to learning and practicality that is both refreshing and intimidating 
>~ [pragprom]


###### The word pragmatic comes from the Latin *pragmaticus* -"skilled in business"-meaning "fit for use." {style=color:LightSteelBlue}

#### What Makes a Pragmatic Programmer? {style=color:SkyBlue}
- **Early adopter / fast adapter**
  - When given something new, you can grasp it quickly and integrate it with the rest of yoour knowledge.

- **Inquisitive**
  - You tend to ask questions - *how did you do that? Did you have problems with that library? What's this quantum computing I've heard about? How are symbolic links implemented?*

- **Critical thinker**
  -You rarely take things as given without first getting the facts. "Because that's the way it's done", you smell a challenge.

- **Realistic**
  - You try to understand the underlying nature of each problem you face. This realism gives you a good feel for how difficult things are, and how long things will take.

- **Jack of all trades**
  - Although your current job may require you to be a specialist, you will always be able to move on to new areas and new challenges.

### 1. Care about your craft {style=color:LightPink}
### 2. Think! About your work {style=color:LightPink}

In order to be a Pragmatic Programmer, we're challenging you to think about what you're doing while you're doing it. This isn't a one-time audit of current practices-it's an ongoing critical appraisal of every decision you make, every day, and on every project. Never run on auto-pilot. Constantly be thinking, critiquing your work in real time. THINK!, is the Pragmatic Programmer's mantra.

The reward is a more active involvement with a job you love, a feeling mastery over an increasing range of subjects, and pleasure in a feeling of continuous improvement.

It was their belief in their indivudual contributions that sustaines the projects: *We who cut mere stones must always be envisioning cathedrals*

*"Kaizen"* is a Japanese term that captures the concept of continuously making many small improvements.

Every day, work to refine the skills you have and to add new tolls to your repertoire.

-----
## A pragmatic philosophy {style=color:IndianRed}
----

What distinguishes Pragmetic Programmers? We feel it's an attitude, a style, a philosophy of approaching problemas and their solutions. They think beyond the immediate problem, placing it in its larger context and seeking out the bigger picture.

Another key to their success is that Pragmatic Programmers take responsibility for everything they do.

#### It's your life {style=color:SkyBlue}

> *I'm not in this world to live up to your expectations and you're not in this world to live up to mine ~Bruce Lee* 

### 3. You have agency {style=color:LightPink}

Does your work enviironment suck? Is your job boring? Try to fix it. But don't try forever. As Martin Fowler says, "you can change your organization or change your organization".

#### The cat ate my source code {style=color:SkyBlue}

> *The greatest of all weaknesses is the fear of appearing weak. ~J.B. Bossuet, Politics from Holy Writ, 1709*

Pragmatic Programmers take charge of therir own career, and aren't afraid to admit ignorance or error.

Despite thorough testing, good documentation, and sold automation, things go wrong. Deliveries are late. Unforeseen technical problems come up.

###### Team trust {style=color:LightSteelBlue}

These things happen, and we try to deal with them as professionally as we can. This means being honest and direct.

In a healthy environment based in trust, you can safely speak your mind, present your ideas, and rely on your team members who can in turn rely on you.

###### Take Responsibility {style=color:LightSteelBlue}

When you make a mistake (as we all do) or an error in judgment, admit it honestly and try to offer options.

Don't blame someone or something else, or make up an excuse. Don't blame all the problems on a vendor, a programming language, management, or your coworkers. Any and all of these may play a role, but it is up to you to provide solutions, not excuses.

### 4. Provide options, don't make lame excuses {style=color:LightPink}

Before you approach anyone to tell them why something can't be done, is late, or is broken, stop and listen to yourself. Talk to the rubber duck on your monitor, or the cat. Does your excuse sound reasonable, or stupid? How's it going to sound your boss?

Will they assk, "Have you tried this..." or "Didn't you consider that?" How will you respond? Before you go and tell them the bad news, is there anything else you can try? Sometimes, you just know what they are going to say, so save them the trouble.

Instead of excuses, provide options. Don't say it can't be done; explain what can be done to salvage the situation.

Don't be afraid to ask, or to admit that you need help.

Try to flush out the lame excuses before voicing them aloud.

- When you find yourself saying, "I don't know," be sure to follow it up with "-but I'll find out." It's a great way to admit what you don't know, but then take responsibility like a pro.

#### Software entropy {style=color:SkyBlue}

Entropy  is a term from physics that referes to the amount of "disorder" in a system. Unfortunately, the laws of thermodynamics guarantee that the entropy in the universe tends toward a maximun. When disorder increases in software, we call it "software rot." "Technical debt," with the implied notion that they'll pay it back someday.

### 5. Don't live with broken windows {style=color:LightPink}

Don't leave "broken windows" (bad designs, wrong decisions, or poor code) unrepaired. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a "Not Implemented" message, or substitute dummy data instead. Take some action to prevent further damage and to show that you're on top of the situation.

But neglect accelerates the rot faster than any other factor.

You may be thinking that no one has the time to go around cleaning up all the broken glass of a project. If so, then you'd better plan on getting a dumpster, or moving to another neighborhood. Don't let entropy win.

###### First, do not harm {style=color:LightSteelBlue}

Andy once had an acquaintance who was obscenely rich. His house was immaculate, loaded with priceless antiques. One day, a tapestry that was hanging a little too close to a fireplace caught on fire. The fire department rushed in to save the day-and the house. But before they dragged their big, dirty hoses into the houses, they stopped- with the fire raging-to roll out a mat between the front door ad source of the fire.

They didn't want to mess up the carpet.

they clearly had assessed the situation, were confident of their ability to manage the fire, and were careful not to inflict unnecessary damage to the property. That's the way it must be with software: don't cause collateral damage just because there's a crisis of some sort. One broken window is one too many.

**Just tell yourself, No "broken windows"**

#### Stone soup and boiled frogs {style=color:SkyBlue}

You may be in a situation where you know exactly what needs doing and how to do it. The entire system just appears before your eyes-you know it's right.
People will form committees, budgets will need approval, and things will get complicated. Everyone will guard their own resources. Sometimes this is called "start-up fatigue."

It's time to bring out the stones. Work out what you can reasonably ask for. Develop it well. Once you've got it, show people, and let them marvel. Then say "of course, it would be better if we added..." Pretend it's not important. Sit back and wait for them to start asking you to add the functionality you originally wanted.

### 6. Be a catalyst for change {style=color:LightPink}

###### The villagers' side {style=color:LightSteelBlue}

### 7. Remember the Big Picture  {style=color:LightPink}

In the broken window theory, people lose the will to fight entropy because they perceive that no one else cares.

Keep an eye on the big picture. Constantly review what's happening around you, not just what you personally are doing.

#### Good-enough software {style=color:SkyBlue}
> Striving to better, oft we mar what's well ~ Shakespeare, King Lear

You can discipline yourself to write software that's good enough-good enough for your users, for future maintainers, for your own peace of mind.

###### Involve your users in the Trade-Off {style=color:LightSteelBlue}

The scope and quality of the system you produce should be discussed as part of that system's requirements.

### 8. Make quality a requirements issue {style=color:LightPink}

###### Know when to stop {style=color:LightSteelBlue}

Don't spoil a perfectly good program by overembellishment and overrefinement. Move on, and let your code stand in its own right for a while. It may not be perfect. Don't worry: it could never be perfect.

#### Your knowledge portfolio {style=color:SkyBlue}
> An investment in knowledge always pays the best interest. ~ Benjamin Franklin

Your ability to learn new things is your most important strategic asset. But how do you learn how to learn, and how do you know what to learn?

###### Your knowledge portfolio{style=color:LightSteelBlue}

Managing a knowledge portfolio is very similar to managing a financial portfolio:

1. Serious investors invest regularly-as a habit.
2. Diversification is the key to long-term success.
3. Smart investors balance their portfolios between conservative and high-risk, high-reward investments.
4. Investors try to buy low and sell high for maximum return.
5. Portfolios should be reviewed and rebalances periodically.

###### Building your portfolio {style=color:LightSteelBlue}

***Invest regularly***

* You must invest in your knowledge portfolio regularly, even if it's a small amount.

***Diversify***

* The more different things you know, the more valuable you are. As a baseline, you need to know the ins and outs of the particular technology you are working with currently. Buy don't stop there. The face of computing changes rapidly-hot technology today may well be close to useless (or at least not in demand) tomorrow. the more technologies you are comfort-able with, the better you will be able to adjust to change. And don't forget all the other skills you need, including those in non-technical areas.

***Manage risk***

* Technology exists along a spectrum from risky, potentially high-reward to low-risk, low-reward standards. It's not a good idea to invest all of your money in high-risk stocks that might collapse suddenly, nor should you invest all of it conservatively and miss out on possible opportunities. Don't put all your technical eggs in one basket.

***Buy low, sell high***

* Learning an emerging technology before it becomes popular can be just as hard as finding an undervalued stock, but the payoff can be just as rewarding. Learning Java back when it was first introduced and unknown may have been risky at the time, but it paid off handsomely for the early adopters when it became an industry mainstay later.

***Review and rebalance***

* This is a very dynamic industry. That hot technology you started investigating last month might be stone cold by now. Maybeyou need to brush up on that database technology that you haven't used in a while. Or perhaps you could be better positioned for that new job opening if you tried out that other language...

### 9. Invest regularly in your knowledge portfolio {style=color:LightPink}

###### Goals {style=color:LightSteelBlue}

***Learn at least one new language every year***

* Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a ryt. Additionally, learning many languages is easy thanks to the wealth of freely available software.

***Read a technical book each month***

* Browse the booksellers for technical books on interesting topics related to your current project. Once you're in the habit, read a book a month. After you've mastered the technologies you're currently using, branch out and study some that don't relate to your project.

***Read nontechnical books, too***

* It is important to remember that computers are used by people-people whose needs you are trying to satisfy. You work with people, are employed by people, and get hacked by people. Don't forget the human side of the equation, as that requires an entirely different skill set. 

***Take classes***

* Look for interesting courses at a local or online college or university, or perhaps at the next nearby trade show or conference
.
***Participate in local user groups and meetups***

* Isolation can be deadly to your career; find out what people are working on outside of your company. Don't just go and listen: actively participate.

***Experiment with different environments***

* If you've worked only in Windows, spend some time with Linux. If you've used only makefiles and an editor, try a sophisticated IDE with cutting-edge features, and vice versa.

***Stay current***

* Read news and posts online on technology different from that of your current project. It's a great way to find out what experiences other people are having with it, the particular jargon they use, and so on.

Get familiar with object orientation, for instance, and you'll write  procedural programs differently. Undestand the functional programming paradigm and you'll write object-oriented code differently, and so on.

###### Opportunities for learning {style=color:LightSteelBlue}

So you're reading voraciously, you're on top of all the latest breaking developments in your field, and somebody asks you a question. You don't have the faintest idea what the answer is, and freely admit as much.

Don't let it stop there. Take it as a personal challenge to find the answer.

If you can't find the answer yourself, find out who can. Don't let it rest. Talking to other people will help build your personal network, and you may surprise yourself by finding solutions to other, unrelated problems along the way. And that old portfolio just keeps getting bigger...


###### Critical thinking {style=color:LightSteelBlue}


----
## A pragmatic approach {style=color:IndianRed}
----
----
## The basic tools {style=color:IndianRed}
----
----
## Pragmatic Paranoia {style=color:IndianRed}
----
----
## Bend, or break {style=color:IndianRed}
----
## Concurrency {style=color:IndianRed}
----
----
## While you are coding {style=color:IndianRed}
----
----
## Before the project {style=color:IndianRed}
----
----
## Pragmatic projects{style=color:IndianRed}
----



